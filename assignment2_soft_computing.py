# -*- coding: utf-8 -*-
"""Assignment2_Soft_Computing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rgxBUb7lhAHd4lMa6MhXadWKKLTgrOXv

# Example using the simulator:
"""

from google.colab import drive
drive.mount('/content/drive')

!ls /content/drive/MyDrive/Assignment_2

import numpy as np
import importlib.util
import random

""" For code to run correctly simulator path must be adjusted to match attached service_simulator.pyc """

simulator_path = '/content/drive/MyDrive/Assignment_2/service_simulator.pyc'

spec = importlib.util.spec_from_file_location("Simulator", simulator_path)
service_simulator = importlib.util.module_from_spec(spec)
spec.loader.exec_module(service_simulator)

def calculate_waiting_times(chromosome, service_simulator):
    """
    Runs the simulator and prints mean and max waiting times for each service.

    Args:
        chromosome (list): Employee allocation across departments.
        service_simulator (object): The simulator instance.

    Returns:
        tuple: (overall_avg_wait, overall_max_wait) for the entire system.
    """
    # Simulate the given employee allocation and retrieve wait times
    _x, wait_times_per_service = service_simulator.init_and_simulate(chromosome)

    # Initialize overall metrics
    total_wait_times = []
    max_waiting_times = []

    # Print mean and max waiting times for each service
    for j in range(len(wait_times_per_service)):
        mean_wait = np.round(np.mean(wait_times_per_service[j]), 3)
        max_wait = np.max(wait_times_per_service[j])

        total_wait_times.extend(wait_times_per_service[j])
        max_waiting_times.append(max_wait)

    # Calculate overall metrics
    overall_avg_wait = np.sum(total_wait_times) / len(total_wait_times)
    overall_max_wait = np.max(max_waiting_times)

    return overall_avg_wait, overall_max_wait

def fitness_function(chromosome, simulator):
    avg_waiting_time, max_waiting_time = calculate_waiting_times(chromosome, simulator)
    fitness = (0.8 * avg_waiting_time) + (0.2 * max_waiting_time)
    return fitness

def single_point_crossover(parent1, parent2):
    """
    Performs single-point crossover between two parent chromosomes.

    Args:
        parent1 (list): First parent chromosome (employee allocation).
        parent2 (list): Second parent chromosome (employee allocation).

    Returns:
        tuple: Two offspring chromosomes.
    """
    # Choose a random crossover point (not at the edges)
    crossover_point = random.randint(1, len(parent1) - 2)

    # Generate two offspring by swapping segments at the crossover point
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]

    # Adjust children to ensure valid employee allocation (sum = 80)
    child1 = adjust_employee_allocation(child1)
    child2 = adjust_employee_allocation(child2)

    return child1, child2

def adjust_employee_allocation(chromosome):
    """
    Adjusts the chromosome to ensure the sum of employees is exactly 80
    and that no department has zero employees.

    Args:
        chromosome (list): A chromosome (list of employee allocations).

    Returns:
        list: Adjusted chromosome with exactly 80 employees and no department empty.
    """
    total_employees = sum(chromosome)
    diff = total_employees - 80

    # If too many employees, decrement randomly until valid
    while diff > 0:
        idx = random.randint(0, len(chromosome) - 1)
        if chromosome[idx] > 1:  # Prevent going below 1
            chromosome[idx] -= 1
            diff -= 1

    # If too few employees, increment randomly until valid
    while diff < 0:
        idx = random.randint(0, len(chromosome) - 1)
        chromosome[idx] += 1
        diff += 1

    # Ensure no department has zero employees
    for i in range(len(chromosome)):
        if chromosome[i] == 0:
            # Reallocate one employee from a random department with more than 1 employee
            while True:
                donor_idx = random.randint(0, len(chromosome) - 1)
                if chromosome[donor_idx] > 1:
                    chromosome[donor_idx] -= 1
                    chromosome[i] += 1
                    break

    return chromosome

def generate_chromosome():
    """Generate a valid chromosome with 50 departments and 80 employees in total, ensuring no department is empty."""
    employees = 80
    departments = 50

    # Start with one employee in each department to avoid zero employees
    chromosome = [1] * departments
    remaining_employees = employees - departments  # Subtract the 1 already assigned to each department

    # Distribute the remaining employees randomly
    while remaining_employees > 0:
        dept = random.randint(0, departments - 1)  # Pick a random department
        chromosome[dept] += 1  # Assign one more employee to that department
        remaining_employees -= 1

    return chromosome

def swap_mutation(chromosome, mutation_rate=0.1):
    """
    Performs swap mutation on a chromosome with a given mutation rate.

    Args:
        chromosome (list): A list representing the employee allocation across departments.
        mutation_rate (float): Probability of mutation (default is 0.1).

    Returns:
        list: Mutated chromosome.
    """
    # Make a copy to avoid mutating the original chromosome directly
    mutated_chromosome = chromosome[:]

    # Perform mutation with a given probability
    if random.random() < mutation_rate:
        # Select two random positions to swap
        i, j = random.sample(range(len(chromosome)), 2)

        # Swap the values
        mutated_chromosome[i], mutated_chromosome[j] = (
            mutated_chromosome[j], mutated_chromosome[i]
        )

    return mutated_chromosome

def initialize_mating_pool(population, fitness_scores):
    """
    Initializes the mating pool using rank selection.

    Args:
        population (list): The current population of chromosomes.
        fitness_scores (list): The fitness scores of the population.

    Returns:
        list: A mating pool selected based on rank.
    """
    # Sort chromosomes by fitness and get their indices
    ranked_indices = sorted(range(len(fitness_scores)), key=lambda i: fitness_scores[i])

    # Rank the fitness scores (1 for the worst fitness, len(fitness_scores) for the best)
    ranks = np.arange(1, len(fitness_scores) + 1)  # Ranks from 1 to population size
    rank_fitness = [ranks[i] for i in ranked_indices]  # Rank list in sorted order

    # Create a selection probability based on rank (higher rank = higher probability)
    total_rank = np.sum(rank_fitness)
    selection_probabilities = [rank / total_rank for rank in rank_fitness]

    # Select parents for the mating pool based on the selection probabilities
    # This allows higher-ranked chromosomes to have a higher chance of being selected
    # Instead of directly using np.random.choice on the 2D population array,
    # we select indices and then use those indices to retrieve chromosomes from the population.
    selected_indices = np.random.choice(len(population), size=len(population), p=selection_probabilities, replace=True)
    mating_pool = [population[i] for i in selected_indices]

    return mating_pool

def genetic_algorithm(population_size=50, generations=20, mutation_rate=0.1):
    """Runs the Genetic Algorithm."""
    # Initialize population
    population = [generate_chromosome() for _ in range(population_size)]
    best_chromosome = None
    best_fitness = float('inf')

    for generation in range(generations):
        # Evaluate fitness for each chromosome
        fitness_scores = [fitness_function(c, service_simulator) for c in population]

        # Track the best chromosome
        min_fitness = min(fitness_scores)
        if min_fitness < best_fitness:
            best_fitness = min_fitness
            best_chromosome = population[fitness_scores.index(min_fitness)]

        print(f"Generation {generation + 1} | Best Fitness: {best_fitness}")

        # Initialize mating pool using rank selection
        mating_pool = initialize_mating_pool(population, fitness_scores)

        # Generate new population through crossover and mutation
        new_population = []
        for _ in range(population_size // 2):
            # The 'mating_pool' is already a list, so 'tolist()' is unnecessary.
            # Directly sample from 'mating_pool'.
            parent1, parent2 = random.sample(mating_pool, 2)
            child1, child2 = single_point_crossover(parent1, parent2)
            new_population.extend([child1, child2])

        # Apply mutation
        new_population = [swap_mutation(c, mutation_rate) for c in new_population]

        population = new_population

    # Print the best employee assignment in the required format
    print("Best employee assignment:")
    print(best_chromosome)
    return best_chromosome

"""employee_setting = [1 for j in range(50)]
employee_setting[0] = 31
_x, wait_times_per_service = service_simulator.init_and_simulate(employee_setting)"""

"""# This is how we will test the performance of your best employee assignment"""

best_chromosome = genetic_algorithm()
means = [0 for _ in range(10)]
maxs = [0 for _ in range(10)]
for _ in range(10):
  _x, wait_times_per_service = service_simulator.init_and_simulate(best_chromosome)
  sums = [np.sum(wait_times_per_service[j]) for j in range(len(wait_times_per_service))]
  counts = [len(wait_times_per_service[j]) for j in range(len(wait_times_per_service))]
  maximums= [np.max(wait_times_per_service[j]) for j in range(len(wait_times_per_service))]
  means[_] =  np.sum(sums)/np.sum(counts)
  maxs[_] = np.max(maximums)

print(means)
print(maxs)
print("Mean waiting time averaged over 10 simulations : ", np.mean(means))
print("Max waiting time  averaged over 10 simulations : ", np.mean(maxs))
